grammar org.bynar.versailles.xtext.VersaillesLang

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate versaillesLang "http://www.bynar.org/versailles/xtext/VersaillesLang"


CompilationUnit hidden(WS, NL, ML_COMMENT, SL_COMMENT):
	{CompilationUnit} statements=Statements ("return" expression=Expression)? Sep*
;
Sep hidden (WS, ML_COMMENT, SL_COMMENT):
	NL | ";"
;

Name: ID_LOWER | "pass" | "fail" | "let" | "forget" | "remember" | "def" | "letdef" | "type" | "lettype" |
	  "if" | "else" | "fi" | "case" | "match" | "in" | "from" | "loop" | "until" | "do" |
	  "module" | "for" | "where" | "abstract" | ID_BACKTICK | TypeName
;
TypeName: ID_UPPER | ID_FORWARDTICK;
NamePath: steps+=Name ("." steps+=Name)*;


Statement:
		{PassStmt} "pass"
	|	{FailStmt} "fail"
	|	{LetStmt} "let" pattern=Expression ("=" value=Expression)?
	|	{ForgetStmt} "forget" pattern=Expression "=" value=Expression
	|	{RememberStmt} "remember" pattern=Expression "=" value=Expression
	|	{IfStmt} "if" condition=Expression "then" then=Statements (=> "else" else=Statements)? ("fi" assertion=Expression)?
	|   {LoopStmt} ("from" assertion=Expression)? ("do" do=Statements)? ("loop" loop=Statements)? "until" condition=Expression
	|	{CaseStmt} "case" case=LambdaExpr
	|	{DefStmt} ("def"|let?="letdef") name=Name (typeArguments=TupleTypeExpr)? (arguments+=TupleExpr)* (title=STRING)? (description=InterpolatedString)?
					    ( janusClass=JanusClassExpression name2=Name? results=TupleExpr (title2=STRING)? (description2=InterpolatedString)? ("{" statements=Statements "}")?
				        | ":" valueType=TypeExpression "=" value=Expression)
	|	{TypeStmt} ("type"|let?="lettype") name=Name typeArguments=TupleTypeExpr? (arguments+=TupleExpr)* (title=STRING)? (description=InterpolatedString)? 
						(":" kind=TypeExpression)? "=" type=TypeExpression
	|   {ModuleStmt} "module" path=NamePath (title=STRING)? (description=InterpolatedString)? "{" statements=Statements "}"
;
Statements:
	{Statements} ((statements+=Statement)? Sep)*
;

Expression:
	ExpressionLambda
;
JanusClass: {JanusClass} op=("->" | "<-" | "<->" | ">->" | "<-<" | ">-<" | "<>-<>");
JanusClassExpression returns JanusClassExpression:
		JanusClass
	|	{GenericJanusClass} ">-" variable=TypeVariable "->"
	|   {GenericBackwardJanusClass} "<-" variable=TypeVariable "-<"
;
LambdaExpr:
	pattern=ExpressionIf janusClass=JanusClass body=Expression
;
ExpressionLambda returns Expression:
	ExpressionIf ({LambdaExpr.pattern=current} janusClass=JanusClass body=Expression)?
;
ExpressionIf returns Expression:
    ExpressionMatch ( {IfExpr.then=current} => "if" condition=Expression "else" else=ExpressionMatch
    	            | {WhereExpr.then=current} => "where" condition=ExpressionMatch)*
;
ExpressionMatch returns Expression:
	ExpressionDisj ({MatchExpr.index=current} => "match" "{" statements=Statements "}")*
;
OrOp returns Operator: {Operator} op="||";
ExpressionDisj returns Expression:
	ExpressionConj ({BinaryExpr.left=current} => op=OrOp right=ExpressionConj)*
;
AndOp returns Operator: {Operator} op="&&";
ExpressionConj returns Expression:
	ExpressionComp ({BinaryExpr.left=current} => op=AndOp right=ExpressionComp)*
;
ComparisionOp returns Operator: {Operator} op=("==" | "<" | ">" | "<=" | ">=" | "!=" | "in");
ExpressionComp returns Expression:
	ExpressionTyped ({BinaryExpr.left=current} op=ComparisionOp => right=ExpressionAdd)*
;
ExpressionTyped returns Expression:
	ExpressionConcat ({TypedExpr.base=current} => ":" type=TypeExpression)?
;
ConcatOp returns Operator: {Operator} op=("++");
ExpressionConcat returns Expression:
	ExpressionAdd ({BinaryExpr.left=current} => op=ConcatOp right=ExpressionMul)*
;
AddOp returns Operator: {Operator} op=("+" | "-");
ExpressionAdd returns Expression:
	ExpressionMul ({BinaryExpr.left=current} => op=AddOp right=ExpressionMul)*
;
MulOp returns Operator: {Operator} op=("*" | "/" | "%");
ExpressionMul returns Expression:
	ExpressionUn ({BinaryExpr.left=current} => op=MulOp right=ExpressionUn)*
;
UnaryOp returns Operator: {Operator} op=("~" | "-" | "!");
ExpressionUn returns Expression:
		{UnaryExpr} => op=UnaryOp expr=ExpressionUn
	|   ExpressionAppl
;
ExpressionAppl returns Expression:
	ExpressionSimple ( {ApplicationExpr.function=current} => argument=TupleExpr
		             | {TypeApplicationExpr.function=current} => argument=TupleTypeExpr 
		             | {MemberAccessExpr.base=current} => "." memberName=Name)*
;
ExpressionSimple returns Expression:
		Variable
	|	{NumberLiteral} value=NUMBER
	|	{StringLiteral} value=STRING
	|	{BlockExpr} "{" statements=Statements ("return" scope=Expression)? Sep* "}"
	|	{ListExpr} "[" indices=IndexExpr "]"
	|	InterpolatedString
	|	TupleExpr
	|	{TypeExpr} "@" type=TypeExpression
	|	{SpecialVariable} "_"
;
Variable:
	(linear?="?")? name=Name
;
InterpolatedString:
		strings+=INTERPOL_FULL
	|   strings+=INTERPOL_START expressions+=Expression (strings+=INTERPOL_MIDDLE expressions+=Expression)* strings+=INTERPOL_END
;
TupleExpr returns Expression:
		{TupleExpr} "(" ")"
	|	{TupleExpr} "(" positional+=Expression ("," positional+=Expression)* ("," names+=Name "=" named+=Expression)* (forceTuple?=",")?  ")"
	|	{TupleExpr} "(" names+=Name "=" named+=Expression ("," names+=Name "=" named+=Expression)* (forceTuple?=",")?")"
;
IndexExpr:
		IndexExprSimple ( {ComprehensionExpr.creator=current} (steps+=ComprehensionStep)+
			            | ({SequenceIndexExpr.first=current} "," second=IndexExprSimple)* ","?)
;
IndexExprSimple:
		{SingletonIndexExpr} index=Expression ({RangeIndexExpr.from=current} ".." to=Expression)?
;
ComprehensionStep: "for" pattern=Expression "from" list=Expression ("if" condition=Expression)?;

TypeExpression:
	TypeFun
;
TypeFun returns TypeExpression:
	TypeModifiers ({FunctionTypeExpr.argumentType=current} => functionClass=JanusClassExpression resultType=TypeExpression)?
;
TypeModifiers returns TypeExpression:
	TypeExtension
;
TypeExtension returns TypeExpression:
	TypeConcretion ({TypeExtension.base=current} => "{" block=Statements "}")*
;
TypeConcretion returns TypeExpression:
	TypeSimple ( {TypeValueConcretion.function=current} => argument=TupleExpr
		       | {TypeConcretion.base=current} => argument=TupleTypeExpr
		       | {TypeMemberAccessExpr.base=current} => "." memberName=Name)*
;
TypeSimple returns TypeExpression:
		{AbstractTypeExpr} "abstract"
	|	{TypeNumberLiteral} value=NUMBER
	|	{TypeStringLiteral} value=STRING
	|	{ValueType} value=TupleExpr
	|	{ValueType} "type" value=Expression
	|	TypeVariable
	|	TupleTypeExpr
;
TypeVariable:
	 name=TypeName
;
TupleTypeExpr returns TypeExpression:
		{TupleTypeExpr} "[" "]"
	|	{TupleTypeExpr} "[" => positional+=TypeExpression ("," positional+=TypeExpression)* ("," names+=Name ":" named+=TypeExpression)* (forceTuple?=",")? "]"
	|	{TupleTypeExpr} "[" names+=Name ":" named+=TypeExpression => ("," names+=Name ":" named+=TypeExpression)* (forceTuple?=",")? "]"
;

terminal ID_LOWER:
('a'..'z')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal ID_BACKTICK:
'`' (!("\n"|'`'))* '`'
;
terminal ID_UPPER:
('A'..'Z')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal ID_FORWARDTICK:
'´' (!("\n"|'´'))* '´'
;
terminal fragment DEC:
	('0'..'9')
;
terminal fragment OCT:
	('0'..'7')
;
terminal fragment HEX:
	('0'..'9' | 'a'..'f' | 'A'..'F')
;
terminal fragment BIN:
	('0'..'1')
;
terminal NUMBER:
		DEC(DEC|'_')* ('.' (DEC|'_')*)? (('e'|'E'|'p'|'P') ('+' | '-')? DEC(DEC|'_')*)?
	|	('0d'|'0D') DEC(DEC|'_')* ('.' (DEC|'_')*)? (('p'|'P') ('+' | '-')? DEC(DEC|'_')*)?
	|	('0x'|'0X') HEX(HEX|'_')* ('.' (HEX|'_')*)? (('p'|'P') ('+' | '-')? HEX(HEX|'_')*)?
	|	('0b'|'0B') BIN(BIN|'_')* ('.' (BIN|'_')*)? (('p'|'P') ('+' | '-')? BIN(BIN|'_')*)?
	|	('0o'|'0O') OCT(OCT|'_')* ('.' (OCT|'_')*)? (('p'|'P') ('+' | '-')? OCT(OCT|'_')*)?;

terminal STRING:
'"' ( '\\'('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"';
terminal INTERPOL_FULL:
"'" (!("'"|"$")|"''"|"$$")* "'";
terminal INTERPOL_START:
"'" (!("'"|"$")|"''"|"$$")* "$";
terminal INTERPOL_MIDDLE:
"$" (!("'"|"$")|"''"|"$$")* "$";
terminal INTERPOL_END:
"$" (!("'"|"$")|"''"|"$$")* "'";
terminal ML_COMMENT :
'/*' -> '*/';
terminal SL_COMMENT :
'//' !('\n'|'\r')* ('\r'? '\n')?;
terminal WS :
(' '|'\t')+;
terminal NL: ('\r'|'\n')+;